[{"content":"A linked list can be implemented with pointers and dynamic memory allocation\nstruct node { int u; struct node* next; node(int x): u(x), next(nullptr) {} }* head=nullptr; int sz, i; // insert node with value x after the jth node void insert(int x, int j) { sz++; node* n=new node(x); if (!j) { // if j==0, insert before head n-\u0026gt;next=head; head=n; } else { // else iterate until insertion node* cur=head; for (i=1; i\u0026lt;j; i++, cur=cur-\u0026gt;next); n-\u0026gt;next=cur-\u0026gt;next; cur-\u0026gt;next=n; } } void erase(int j) { // assume the jth node exists sz--; if (j==1) head=head-\u0026gt;next; else { node* cur=head; for (i=1; i\u0026lt;j-1; i++, cur=cur-\u0026gt;next); node* x=cur-\u0026gt;next; cur-\u0026gt;next=x-\u0026gt;next; delete x; } } int query(int j) { // assume the jth node exists node* cur=head; for (i=1; i\u0026lt;j; i++, cur=cur-\u0026gt;next); return cur-\u0026gt;u; } ","date":"2023/01/09","permalink":"/posts/linked-list-implementation/","section":"Posts","summary":"A linked list can be implemented with pointers and dynamic memory allocation\nstruct node { int u; struct node* next; node(int x): u(x), next(nullptr) {} }* head=nullptr; int sz, i; // insert node with value x after the jth node void insert(int x, int j) { sz++; node* n=new node(x); if (!","title":"Linked List Implementation"},{"content":"","date":"2023/01/09","permalink":"/tags/linked-list/","section":"Tags","summary":"","title":"linked-list"},{"content":"","date":"2023/01/09","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Maintain a stack of result of the arithemetic expression. Push numbers into the stack. If it is an operator, pop two numbers out of the stack and evaluate it with the operator, and push the result back to the stack. The answer is the result left in the stack in the end, assume the expression is in valid Reverse Polish Notation.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; stack\u0026lt;int\u0026gt; sol; // the solution; assume int vector\u0026lt;string\u0026gt; rpn; // assume tokenized rpn expression // supports simple arithmetics: +-*/ int eval_expr(int x, int y, char t) { // assume all operators only single charactered switch(t) { case \u0026#39;+\u0026#39;: return x+y; case \u0026#39;-\u0026#39;: return x-y; case \u0026#39;*\u0026#39;: return x*y; case \u0026#39;/\u0026#39;: return x/y; default: return 0; } } int eval_rpn() { // clean-up while (!sol.empty()) sol.pop(); for (auto\u0026amp; t: rpn) { if (isdigit(t[0])) // assume all numbers valid sol.push(stoi(t)); else { // an operator int y=sol.top(); sol.pop(); int x=sol.top(); sol.pop(); sol.push(eval_expr(x, y, t[0])); } } // assume rpn valid then the number left in the stack is the solution return sol.top(); } ","date":"2023/01/09","permalink":"/posts/evaluate-reverse-polish-notation/","section":"Posts","summary":"Maintain a stack of result of the arithemetic expression. Push numbers into the stack. If it is an operator, pop two numbers out of the stack and evaluate it with the operator, and push the result back to the stack.","title":"Evaluate Reverse Polish Notation"},{"content":"","date":"2023/01/09","permalink":"/tags/rpn/","section":"Tags","summary":"","title":"RPN"},{"content":"","date":"2023/01/09","permalink":"/tags/stack/","section":"Tags","summary":"","title":"stack"},{"content":"Given a sequence of parentheses, determine if the parentheses are balanced or not. For example, \u0026ldquo;(())(()())\u0026rdquo; is balanced but \u0026ldquo;(()()))(\u0026rdquo; is not balanced.\nSolution: Maintain a stack of left parentheses. If a right parentheses mismatches, the sequence is unbalanced.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; // the sequence stack\u0026lt;char\u0026gt; st; // stack of \u0026#39;(\u0026#39; bool is_balance() { getline(cin, s); for (auto\u0026amp; c: s) { if (c==\u0026#39;(\u0026#39;) st.push(c); else if (st.empty()) // no \u0026#39;(\u0026#39; in the stack but there is a \u0026#39;)\u0026#39; to be matched return false; else // pop the top \u0026#39;(\u0026#39; if matched st.pop(); } if (st.empty()) // every \u0026#39;(\u0026#39; in the stack has been matched return true; else // there are unmatched \u0026#39;(\u0026#39; return false; } ","date":"2023/01/08","permalink":"/posts/parentheses-balance/","section":"Posts","summary":"Given a sequence of parentheses, determine if the parentheses are balanced or not. For example, \u0026ldquo;(())(()())\u0026rdquo; is balanced but \u0026ldquo;(()()))(\u0026rdquo; is not balanced.\nSolution: Maintain a stack of left parentheses. If a right parentheses mismatches, the sequence is unbalanced.","title":"Parentheses Balance"},{"content":"","date":"2023/01/08","permalink":"/tags/graph/","section":"Tags","summary":"","title":"graph"},{"content":"Depth-first Search\u003e Depth-first Search # Depth-first search explores unvisited path and goes as far as possible, and backtracks to explore a new path. It repeats until there is no path unexplored. I assume the graph is implemented as a linked adjacency list Graph Implementation.\nDepth-first search can be implemented recursively which resembles using a stack:\nstruct edge { int to, next, w; } e[E\u0026lt;\u0026lt;1]; // e[E] if directed graph int head[V], i; int visit[V]; // visit[i] marks if vertex i is visited or not // to start a search, call at the source vertex void dfs(int u) { visit[u]=true; int i=head[u]; while (i) { if (!visit[e[i].to]) dfs(e[i].to); i=e[i].next; } } Example of using $dfs$ to find a path in a graph:\n// ૮ ˶ᵔ ᵕ ᵔ˶ ა #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct edge { int to, next, w; } e[100]; int head[101], i, u, v, w, d; bool found; void add_edge(int u, int v, int w) { e[++i]={v, head[u], w}; head[u]=i; e[++i]={u, head[v], w}; head[v]=i; } void dfs(int u, int p) { if (u==d) { printf(\u0026#34;%d \u0026#34;, u); found=true; return; } int i=head[u]; while (i) { if (e[i].to!=p) dfs(e[i].to, u); if (found) { printf(\u0026#34;%d \u0026#34;, u); return; } i=e[i].next; } } int main() { while (cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;w) { add_edge(u, v, w); } d=6; dfs(1, 0); } /* Input: 1 2 1 1 3 1 1 4 1 2 3 1 2 4 1 3 4 1 3 5 1 4 5 1 5 6 1 Output: 6 5 4 1 */ Bredth-first Search\u003e Bredth-first Search # Breadth-first search is very similar to depth-first search, but it uses a queue to maintain the unexplored vertices and thus finds the shortest path given an unweighted graph.\nstruct edge { int to, next, w; } e[E\u0026lt;\u0026lt;1]; // e[E] if directed graph int head[V], i; int visit[V]; // visit[i] marks if vertex i is visited or not queue\u0026lt;int\u0026gt; q; // to start a search, call at the source vertex void bfs(int u) { q.push(u); visit[u]=true; while (!q.empty()) { int v=q.front(), i=head[v]; q.pop(); while (i) { if (!visit[e[i].to]) { q.push(e[i].to); visit[e[i].to]=true; } i=e[i].next; } } } We can do bidirection search with $bfs$ from both vertices $u$ and $v$ in order to speed up finding the shortet path between $u$ anad $v$.\n","date":"2023/01/08","permalink":"/posts/graph-traversal/","section":"Posts","summary":"Depth-first Search\u003e Depth-first Search # Depth-first search explores unvisited path and goes as far as possible, and backtracks to explore a new path. It repeats until there is no path unexplored.","title":"Graph Traversal"},{"content":"Linked Adjacency List\u003e Linked Adjacency List # A graph can be implemented as a linked adjacency list (more preferred than adjancency matrix or edge list due to memory constraints)\nstruct edge { int to, next, w; } e[E\u0026lt;\u0026lt;1]; // e[E] if directed graph int head[V], i; void add_edge(int u, int v, int w) { e[++i]={v, head[u], w}; head[u]=i; e[++i]={u, head[v], w}; // undirected graph head[v]=i; } // traversing the graph void dfs(int u, int p) { int i=head[u]; while (i) { // terminate when i=0 if (e[i].to!=p) dfs(e[i].to, u); i=e[i].next; // linked list } } ","date":"2023/01/07","permalink":"/posts/graph-implementation/","section":"Posts","summary":"Linked Adjacency List\u003e Linked Adjacency List # A graph can be implemented as a linked adjacency list (more preferred than adjancency matrix or edge list due to memory constraints)\nstruct edge { int to, next, w; } e[E\u0026lt;\u0026lt;1]; // e[E] if directed graph int head[V], i; void add_edge(int u, int v, int w) { e[++i]={v, head[u], w}; head[u]=i; e[++i]={u, head[v], w}; // undirected graph head[v]=i; } // traversing the graph void dfs(int u, int p) { int i=head[u]; while (i) { // terminate when i=0 if (e[i].","title":"Graph Implementation"},{"content":" CF580C - Kefa and Park\nDepth-first search but maintain $s$ the number of consecutive cats till vertex $u$. If $s\u0026gt;m$, leaves. If $u$ is not vertex 1 and the degree of $u$ is 1, i.e., it is a leaf, it is an answer.\nThe solution is $O(n)$.\n// ૮ ˶ᵔ ᵕ ᵔ˶ ა #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[100001], n, m, i, u, v, ans; vector\u0026lt;int\u0026gt; tree[100001]; void dfs(int u, int p, int s) { if (s\u0026gt;m) return; if (u!=1\u0026amp;\u0026amp;tree[u].size()==1) ans++; for (auto\u0026amp; v: tree[u]) { if (v==p) continue; if (a[v]) dfs(v, u, s+1); else dfs(v, u, 0); } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } while (cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v) { tree[u].push_back(v); tree[v].push_back(u); } dfs(1, 0, a[1]); printf(\u0026#34;%d\u0026#34;, ans); } ","date":"2023/01/07","permalink":"/posts/cf-580c/","section":"Posts","summary":"CF580C - Kefa and Park\nDepth-first search but maintain $s$ the number of consecutive cats till vertex $u$. If $s\u0026gt;m$, leaves. If $u$ is not vertex 1 and the degree of $u$ is 1, i.","title":"CF580C - Kefa and Park"},{"content":"","date":"2023/01/07","permalink":"/tags/codeforces/","section":"Tags","summary":"","title":"codeforces"},{"content":"","date":"2023/01/07","permalink":"/tags/dfs/","section":"Tags","summary":"","title":"dfs"},{"content":"","date":"2023/01/07","permalink":"/tags/tree/","section":"Tags","summary":"","title":"tree"},{"content":"","date":"2023/01/06","permalink":"/tags/2-pointers/","section":"Tags","summary":"","title":"2-pointers"},{"content":" CF279B - Books\nUse 2-pointers $i, j$ to iterate throught $i=1..n$ to find $j$ such that $\\sum_{k=j}^i a[k] \u0026lt;= t$ is maximized in order to find the $\\max(i-j+1)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[100001], n, t, i, j, s, c; int main() { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;t); for (i=1, j=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); s+=a[i]; while (j\u0026lt;=n\u0026amp;\u0026amp;s\u0026gt;t) { s-=a[j++]; } c=max(c, i-j+1); } printf(\u0026#34;%d\u0026#34;, c); } ","date":"2023/01/06","permalink":"/posts/cf-279b/","section":"Posts","summary":"CF279B - Books\nUse 2-pointers $i, j$ to iterate throught $i=1..n$ to find $j$ such that $\\sum_{k=j}^i a[k] \u0026lt;= t$ is maximized in order to find the $\\max(i-j+1)$.\n#include \u0026lt;bits/stdc++.","title":"CF279B - Books"},{"content":" CF489B - BerSU Ball\nSort arrays $a, b$. Match $a[i], b[j]$ greedily with two pointers $i, j$. Assume $a[x], b[y]$ the first pair inconsistent with the optimal pair. Note that if $a[i^\\prime], b[j^\\prime]$ match, $b[j^\\prime]$ is always the minimum $b[j]$ upon $a[i]$ not paired in array $b$. Let $a[x^\\prime], b[y^\\prime]$ be the optimal pair, then $a[x^\\prime]\\geq a[x]$ and $b[y^\\prime] \u0026gt; b[y]$. Let $tol$ and $tol^\\prime$ be the total number of pairs given by the algorithm and the optimal solution respectively, we can show that $tol^\\prime \\leq tol$, i.e., the solution given by the algorithm is more \u0026ldquo;optimal\u0026rdquo;, which contradicts. Therefore, the greedy is correct.\nThe solution is $O(n\\lg n + m\\lg m)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m, a[101], b[101], i, j, x; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (j=1; j\u0026lt;=m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[j]); } sort(a+1, a+1+n); sort(b+1, b+1+m); for (i=1, j=1; i\u0026lt;=n\u0026amp;\u0026amp;j\u0026lt;=m;) { if (abs(b[j]-a[i])\u0026lt;=1) { x++, i++, j++; } else if (a[i]\u0026lt;b[j]) { i++; } else j++; } printf(\u0026#34;%d\u0026#34;, x); } ","date":"2023/01/05","permalink":"/posts/cf-489b/","section":"Posts","summary":"CF489B - BerSU Ball\nSort arrays $a, b$. Match $a[i], b[j]$ greedily with two pointers $i, j$. Assume $a[x], b[y]$ the first pair inconsistent with the optimal pair. Note that if $a[i^\\prime], b[j^\\prime]$ match, $b[j^\\prime]$ is always the minimum $b[j]$ upon $a[i]$ not paired in array $b$.","title":"CF489B - BerSU Ball"},{"content":"","date":"2023/01/05","permalink":"/tags/greedy/","section":"Tags","summary":"","title":"greedy"},{"content":" CF381A - Sereja and Dima\nLet $x[n]$ be the cards and $l, r$ the left and right pointers. Sereja and Dima takes $\\max(x[l], x[r])$ greedily each round then move the pointers. The game always terminate when $l\u0026gt;r$.\nThe solution is $O(n)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int x[1001], a[2], n, l, r, i; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x[i]); } for (l=1, r=n, i=0; l\u0026lt;=r; i++) { if (x[r]\u0026gt;x[l]) { a[i%2]+=x[r--]; } else { a[i%2]+=x[l++]; } } printf(\u0026#34;%d %d\u0026#34;, a[0], a[1]); } ","date":"2023/01/05","permalink":"/posts/cf-381a/","section":"Posts","summary":"CF381A - Sereja and Dima\nLet $x[n]$ be the cards and $l, r$ the left and right pointers. Sereja and Dima takes $\\max(x[l], x[r])$ greedily each round then move the pointers.","title":"CF381A - Sereja and Dima"},{"content":" CF706B - Interesting Drink\nLet $c[max(x)]$ array such that $a[x]$ is the number of $x$. Let $s[max(x)]$ be the prefix sum of $c[max(x)]$ given by\n$$s[i] = s[i-1] + c[i]$$ with $s[1] = c[1]$.\nThe solution is $s[m]$ for $m \\leq max(x)$, else it is simply $n$.\nThe solution is $O(n+q)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int x, c[100001], s[100001], n, m, q; void solve() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); printf(\u0026#34;%d\\n\u0026#34;, s[min(100000, m)]); } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); c[x]++; } s[1] = c[1]; for (int i=2; i\u0026lt;=100000; i++) { s[i] = s[i-1] + c[i]; } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { solve(); } } ","date":"2023/01/04","permalink":"/posts/cf-706b/","section":"Posts","summary":"CF706B - Interesting Drink\nLet $c[max(x)]$ array such that $a[x]$ is the number of $x$. Let $s[max(x)]$ be the prefix sum of $c[max(x)]$ given by\n$$s[i] = s[i-1] + c[i]$$ with $s[1] = c[1]$.","title":"CF706B - Interesting Drink"},{"content":"","date":"2023/01/04","permalink":"/tags/dp/","section":"Tags","summary":"","title":"dp"},{"content":"","date":"2023/01/04","permalink":"/tags/prefix-sum/","section":"Tags","summary":"","title":"prefix-sum"},{"content":" CF455A - Boredom\nThe problem asks to maximize the score. Given an array $a[n]$, the score given by deleting $a[k]$ is $a[k]m[a[k]]$ where $m[a[k]]$ is the number of $a[k]$ in the array. Precalculate the array $c[\\max(a)]$, where $\\max(a)$ is the maximum $a[k]$, is given by\n$$c[k] = k \\cdot m[k]$$ where $m[k] = 0$ if $k$ does not exists in array $a[n]$ with $c[0] = 0$ defined.\nDefine $dp[n^\\prime]$ the array the maximum score deleting only $a[k]$ for $a[k]=1..n^\\prime$. Then $dp[\\max(a)]$ is the solution given by the state transition equation\n$$dp[n^\\prime] = \\max(dp[n^\\prime - 1], dp[n^\\prime - 2] + c[n^\\prime])$$ with $dp[1] = c[1]$ and $dp[0] = 0$ defined.\nThe solution is $O(n+\\max(a))$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long c[100001], dp[100001]; int n, x; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); c[x] += x; } dp[1] = c[1]; for (int i=2; i\u0026lt;=100000; i++) { dp[i] = max(dp[i-1], dp[i-2]+c[i]); } printf(\u0026#34;%lli\u0026#34;, dp[100000]); } ","date":"2023/01/04","permalink":"/posts/cf-455a/","section":"Posts","summary":"CF455A - Boredom\nThe problem asks to maximize the score. Given an array $a[n]$, the score given by deleting $a[k]$ is $a[k]m[a[k]]$ where $m[a[k]]$ is the number of $a[k]$ in the array.","title":"CF455A - Boredom"},{"content":"Complete Knapsack Problem: Given $a[4]$ weight of items with each value 1 and knapsack capacity $n$, define\n$$dp[n^\\prime] = \\sum_{i=1}^{3} k[i]$$\nthe maximum value with knapsack with capacity $n^\\prime$ such that $k[i] \u0026gt;= 0$ is the number of times $a[i]$ is taken and\n$$\\sum_{i=1}^{3} k[i]a[i] = n^\\prime$$\nNote that if there is no $\\sum_{i=1}^{3} k[i]a[i] = n^\\prime$, we define $dp[n^\\prime] = -1$. The problem gurantees that $dp[n] \\neq -1$.\nThe state transition equation is given by:\n$$dp[n^\\prime] = -1$$ if $dp[n-a[i]] = -1$ for $i=1..3$, and else\n$$dp[n^\\prime] = \\max(dp[n^\\prime-a[1]], dp[n^\\prime-a[2]], dp[n^\\prime-a[3]]) + 1$$ with $dp[0] = 0$.\nWe find $dp[n^\\prime]$ for $n^\\prime = a[i]..n$ incrementally with items $\\lbrace a[1], \\cdots, a[i] \\rbrace$ for $i=1..3$ such that $dp[n] = \\max(dp[n-a[1]], dp[n-a[2]], dp[n-a[3]])$. At each iteration, assuming $dp[n^\\prime-a[i]] \\neq -1$, $dp[n^\\prime] = \\max(dp[n^\\prime-a[i]]+1, dp[n^\\prime])$. Initially no item is taken, so $dp[n^\\prime] = -1$ for all $n^\\prime$. Note that if we only take the item $a[i]$, $dp[n^\\prime] = -1$ for $n^\\prime = 1..a[i]-1$.\nThe solution is $O(n)$.\nCF189A - Cut Ribbon\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, a[4], dp[4001]; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i=1; i\u0026lt;4; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } memset(dp, -1, sizeof(dp)); dp[0] = 0; for (int i=1; i\u0026lt;4; i++) { for (int j=a[i]; j\u0026lt;=n; j++) { if (dp[j-a[i]]==-1) continue; dp[j] = max(dp[j], dp[j-a[i]]+1); } } printf(\u0026#34;%d\u0026#34;, dp[n]); } ","date":"2023/01/04","permalink":"/posts/cf-189a/","section":"Posts","summary":"Complete Knapsack Problem: Given $a[4]$ weight of items with each value 1 and knapsack capacity $n$, define\n$$dp[n^\\prime] = \\sum_{i=1}^{3} k[i]$$\nthe maximum value with knapsack with capacity $n^\\prime$ such that $k[i] \u0026gt;= 0$ is the number of times $a[i]$ is taken and","title":"CF189A - Cut Ribbon"},{"content":"","date":"2023/01/04","permalink":"/tags/complete-knapsack/","section":"Tags","summary":"","title":"complete-knapsack"},{"content":" CF489C - Given Length and Sum of Digits\u0026hellip;\nLet $x$ and $y$ be the maximum and mininum number with length $m$ and sum of digits $s$. Note that maximum sum of digits of length $m$ is $9m$ and if $s=0$, then there are no solutions with length $m\u0026gt;1$.\nConstruct $x$ and $y$ incrementally and greedily but note that $y[1]$ has to be at least 1 such that the length is $m$. The solution is $O(m)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int x[101], y[101]; int main() { int m, s; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;m, \u0026amp;s); if ((m\u0026gt;1\u0026amp;\u0026amp;s==0)||s\u0026gt;9*m) { printf(\u0026#34;-1 -1\u0026#34;); return 0; } int t = s; for (int i=1; i\u0026lt;=m\u0026amp;\u0026amp;t\u0026gt;0; i++) { x[i] = (t\u0026gt;=9)? 9: t; t -= x[i]; } for (int i=m; i\u0026gt;1\u0026amp;\u0026amp;s\u0026gt;1; i--) { y[i] = (s\u0026gt;=10)? 9: s-1; s -= y[i]; } y[1] = s; for (int i=1; i\u0026lt;=m; i++) { printf(\u0026#34;%d\u0026#34;, y[i]); } printf(\u0026#34; \u0026#34;); for (int i=1; i\u0026lt;=m; i++) { printf(\u0026#34;%d\u0026#34;, x[i]); } } ","date":"2023/01/03","permalink":"/posts/cf-489c/","section":"Posts","summary":"CF489C - Given Length and Sum of Digits\u0026hellip;\nLet $x$ and $y$ be the maximum and mininum number with length $m$ and sum of digits $s$. Note that maximum sum of digits of length $m$ is $9m$ and if $s=0$, then there are no solutions with length $m\u0026gt;1$.","title":"CF489C - Given Length and Sum of Digits..."},{"content":"","date":"2022/10/26","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"ToYou トーヨー · ENERGY DRINK ","date":"2022/10/26","permalink":"/","section":"","summary":"ToYou トーヨー · ENERGY DRINK ","title":""},{"content":"","date":"0001/01/01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001/01/01","permalink":"/series/","section":"Series","summary":"","title":"Series"}]
[{"content":"","date":"2023/01/06","permalink":"/tags/2-pointers/","section":"Tags","summary":"","title":"2-pointers"},{"content":" CF279B - Books\nUse 2-pointers $i, j$ to iterate throught $i=1..n$ to find $j$ such that $\\sum_{k=j}^i a[k] \u0026lt;= t$ is maximized in order to find the $\\max(i-j+1)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[100001], n, t, i, j, s, c; int main() { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;t); for (i=1, j=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); s+=a[i]; while (j\u0026lt;=n\u0026amp;\u0026amp;s\u0026gt;t) { s-=a[j++]; } c=max(c, i-j+1); } printf(\u0026#34;%d\u0026#34;, c); } ","date":"2023/01/06","permalink":"/posts/cf-279b/","section":"Posts","summary":"CF279B - Books\nUse 2-pointers $i, j$ to iterate throught $i=1..n$ to find $j$ such that $\\sum_{k=j}^i a[k] \u0026lt;= t$ is maximized in order to find the $\\max(i-j+1)$.\n#include \u0026lt;bits/stdc++.","title":"CF279B - Books"},{"content":"","date":"2023/01/06","permalink":"/tags/codeforces/","section":"Tags","summary":"","title":"codeforces"},{"content":"","date":"2023/01/06","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" CF489B - BerSU Ball\nSort arrays $a, b$. Match $a[i], b[j]$ greedily with two pointers $i, j$. Assume $a[x], b[y]$ the first pair inconsistent with the optimal pair. Note that if $a[i^\\prime], b[j^\\prime]$ match, $b[j^\\prime]$ is always the minimum $b[j]$ upon $a[i]$ not paired in array $b$. Let $a[x^\\prime], b[y^\\prime]$ be the optimal pair, then $a[x^\\prime]\\geq a[x]$ and $b[y^\\prime] \u0026gt; b[y]$. Let $tol$ and $tol^\\prime$ be the total number of pairs given by the algorithm and the optimal solution respectively, we can show that $tol^\\prime \\leq tol$, i.e., the solution given by the algorithm is more \u0026ldquo;optimal\u0026rdquo;, which contradicts. Therefore, the greedy is correct.\nThe solution is $O(n\\lg n + m\\lg m)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m, a[101], b[101], i, j, x; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (j=1; j\u0026lt;=m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[j]); } sort(a+1, a+1+n); sort(b+1, b+1+m); for (i=1, j=1; i\u0026lt;=n\u0026amp;\u0026amp;j\u0026lt;=m;) { if (abs(b[j]-a[i])\u0026lt;=1) { x++, i++, j++; } else if (a[i]\u0026lt;b[j]) { i++; } else j++; } printf(\u0026#34;%d\u0026#34;, x); } ","date":"2023/01/05","permalink":"/posts/cf-489b/","section":"Posts","summary":"CF489B - BerSU Ball\nSort arrays $a, b$. Match $a[i], b[j]$ greedily with two pointers $i, j$. Assume $a[x], b[y]$ the first pair inconsistent with the optimal pair. Note that if $a[i^\\prime], b[j^\\prime]$ match, $b[j^\\prime]$ is always the minimum $b[j]$ upon $a[i]$ not paired in array $b$.","title":"CF489B - BerSU Ball"},{"content":"","date":"2023/01/05","permalink":"/tags/greedy/","section":"Tags","summary":"","title":"greedy"},{"content":" CF381A - Sereja and Dima\nLet $x[n]$ be the cards and $l, r$ the left and right pointers. Sereja and Dima takes $\\max(x[l], x[r])$ greedily each round then move the pointers. The game always terminate when $l\u0026gt;r$.\nThe solution is $O(n)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int x[1001], a[2], n, l, r, i; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x[i]); } for (l=1, r=n, i=0; l\u0026lt;=r; i++) { if (x[r]\u0026gt;x[l]) { a[i%2]+=x[r--]; } else { a[i%2]+=x[l++]; } } printf(\u0026#34;%d %d\u0026#34;, a[0], a[1]); } ","date":"2023/01/05","permalink":"/posts/cf-381a/","section":"Posts","summary":"CF381A - Sereja and Dima\nLet $x[n]$ be the cards and $l, r$ the left and right pointers. Sereja and Dima takes $\\max(x[l], x[r])$ greedily each round then move the pointers.","title":"CF381A - Sereja and Dima"},{"content":" CF706B - Interesting Drink\nLet $c[max(x)]$ array such that $a[x]$ is the number of $x$. Let $s[max(x)]$ be the prefix sum of $c[max(x)]$ given by\n$$s[i] = s[i-1] + c[i]$$ with $s[1] = c[1]$.\nThe solution is $s[m]$ for $m \\leq max(x)$, else it is simply $n$.\nThe solution is $O(n+q)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int x, c[100001], s[100001], n, m, q; void solve() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); printf(\u0026#34;%d\\n\u0026#34;, s[min(100000, m)]); } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); c[x]++; } s[1] = c[1]; for (int i=2; i\u0026lt;=100000; i++) { s[i] = s[i-1] + c[i]; } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { solve(); } } ","date":"2023/01/04","permalink":"/posts/cf-706b/","section":"Posts","summary":"CF706B - Interesting Drink\nLet $c[max(x)]$ array such that $a[x]$ is the number of $x$. Let $s[max(x)]$ be the prefix sum of $c[max(x)]$ given by\n$$s[i] = s[i-1] + c[i]$$ with $s[1] = c[1]$.","title":"CF706B - Interesting Drink"},{"content":"","date":"2023/01/04","permalink":"/tags/dp/","section":"Tags","summary":"","title":"dp"},{"content":"","date":"2023/01/04","permalink":"/tags/prefix-sum/","section":"Tags","summary":"","title":"prefix-sum"},{"content":" CF455A - Boredom\nThe problem asks to maximize the score. Given an array $a[n]$, the score given by deleting $a[k]$ is $a[k]m[a[k]]$ where $m[a[k]]$ is the number of $a[k]$ in the array. Precalculate the array $c[\\max(a)]$, where $\\max(a)$ is the maximum $a[k]$, is given by\n$$c[k] = k \\cdot m[k]$$ where $m[k] = 0$ if $k$ does not exists in array $a[n]$ with $c[0] = 0$ defined.\nDefine $dp[n^\\prime]$ the array the maximum score deleting only $a[k]$ for $a[k]=1..n^\\prime$. Then $dp[\\max(a)]$ is the solution given by the state transition equation\n$$dp[n^\\prime] = \\max(dp[n^\\prime - 1], dp[n^\\prime - 2] + c[n^\\prime])$$ with $dp[1] = c[1]$ and $dp[0] = 0$ defined.\nThe solution is $O(n+\\max(a))$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long c[100001], dp[100001]; int n, x; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i=1; i\u0026lt;=n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); c[x] += x; } dp[1] = c[1]; for (int i=2; i\u0026lt;=100000; i++) { dp[i] = max(dp[i-1], dp[i-2]+c[i]); } printf(\u0026#34;%lli\u0026#34;, dp[100000]); } ","date":"2023/01/04","permalink":"/posts/cf-455a/","section":"Posts","summary":"CF455A - Boredom\nThe problem asks to maximize the score. Given an array $a[n]$, the score given by deleting $a[k]$ is $a[k]m[a[k]]$ where $m[a[k]]$ is the number of $a[k]$ in the array.","title":"CF455A - Boredom"},{"content":"Complete Knapsack Problem: Given $a[4]$ weight of items with each value 1 and knapsack capacity $n$, define\n$$dp[n^\\prime] = \\sum_{i=1}^{3} k[i]$$\nthe maximum value with knapsack with capacity $n^\\prime$ such that $k[i] \u0026gt;= 0$ is the number of times $a[i]$ is taken and\n$$\\sum_{i=1}^{3} k[i]a[i] = n^\\prime$$\nNote that if there is no $\\sum_{i=1}^{3} k[i]a[i] = n^\\prime$, we define $dp[n^\\prime] = -1$. The problem gurantees that $dp[n] \\neq -1$.\nThe state transition equation is given by:\n$$dp[n^\\prime] = -1$$ if $dp[n-a[i]] = -1$ for $i=1..3$, and else\n$$dp[n^\\prime] = \\max(dp[n^\\prime-a[1]], dp[n^\\prime-a[2]], dp[n^\\prime-a[3]]) + 1$$ with $dp[0] = 0$.\nWe find $dp[n^\\prime]$ for $n^\\prime = a[i]..n$ incrementally with items $\\lbrace a[1], \\cdots, a[i] \\rbrace$ for $i=1..3$ such that $dp[n] = \\max(dp[n-a[1]], dp[n-a[2]], dp[n-a[3]])$. At each iteration, assuming $dp[n^\\prime-a[i]] \\neq -1$, $dp[n^\\prime] = \\max(dp[n^\\prime-a[i]]+1, dp[n^\\prime])$. Initially no item is taken, so $dp[n^\\prime] = -1$ for all $n^\\prime$. Note that if we only take the item $a[i]$, $dp[n^\\prime] = -1$ for $n^\\prime = 1..a[i]-1$.\nThe solution is $O(n)$.\nCF189A - Cut Ribbon\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, a[4], dp[4001]; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i=1; i\u0026lt;4; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } memset(dp, -1, sizeof(dp)); dp[0] = 0; for (int i=1; i\u0026lt;4; i++) { for (int j=a[i]; j\u0026lt;=n; j++) { if (dp[j-a[i]]==-1) continue; dp[j] = max(dp[j], dp[j-a[i]]+1); } } printf(\u0026#34;%d\u0026#34;, dp[n]); } ","date":"2023/01/04","permalink":"/posts/cf-189a/","section":"Posts","summary":"Complete Knapsack Problem: Given $a[4]$ weight of items with each value 1 and knapsack capacity $n$, define\n$$dp[n^\\prime] = \\sum_{i=1}^{3} k[i]$$\nthe maximum value with knapsack with capacity $n^\\prime$ such that $k[i] \u0026gt;= 0$ is the number of times $a[i]$ is taken and","title":"CF189A - Cut Ribbon"},{"content":"","date":"2023/01/04","permalink":"/tags/complete-knapsack/","section":"Tags","summary":"","title":"complete-knapsack"},{"content":" CF489C - Given Length and Sum of Digits\u0026hellip;\nLet $x$ and $y$ be the maximum and mininum number with length $m$ and sum of digits $s$. Note that maximum sum of digits of length $m$ is $9m$ and if $s=0$, then there are no solutions with length $m\u0026gt;1$.\nConstruct $x$ and $y$ incrementally and greedily but note that $y[1]$ has to be at least 1 such that the length is $m$. The solution is $O(m)$.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int x[101], y[101]; int main() { int m, s; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;m, \u0026amp;s); if ((m\u0026gt;1\u0026amp;\u0026amp;s==0)||s\u0026gt;9*m) { printf(\u0026#34;-1 -1\u0026#34;); return 0; } int t = s; for (int i=1; i\u0026lt;=m\u0026amp;\u0026amp;t\u0026gt;0; i++) { x[i] = (t\u0026gt;=9)? 9: t; t -= x[i]; } for (int i=m; i\u0026gt;1\u0026amp;\u0026amp;s\u0026gt;1; i--) { y[i] = (s\u0026gt;=10)? 9: s-1; s -= y[i]; } y[1] = s; for (int i=1; i\u0026lt;=m; i++) { printf(\u0026#34;%d\u0026#34;, y[i]); } printf(\u0026#34; \u0026#34;); for (int i=1; i\u0026lt;=m; i++) { printf(\u0026#34;%d\u0026#34;, x[i]); } } ","date":"2023/01/03","permalink":"/posts/cf-489c/","section":"Posts","summary":"CF489C - Given Length and Sum of Digits\u0026hellip;\nLet $x$ and $y$ be the maximum and mininum number with length $m$ and sum of digits $s$. Note that maximum sum of digits of length $m$ is $9m$ and if $s=0$, then there are no solutions with length $m\u0026gt;1$.","title":"CF489C - Given Length and Sum of Digits..."},{"content":"","date":"2022/10/26","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"ToYou トーヨー · ENERGY DRINK ","date":"2022/10/26","permalink":"/","section":"","summary":"ToYou トーヨー · ENERGY DRINK ","title":""},{"content":"","date":"0001/01/01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001/01/01","permalink":"/series/","section":"Series","summary":"","title":"Series"}]
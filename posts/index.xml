<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Luma's Shoka</title><link>https://luma0724.github.io/posts/</link><description>Recent content in Posts on Luma's Shoka</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 26 Oct 2022 10:00:43 +0800</lastBuildDate><atom:link href="https://luma0724.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Linked List Implementation</title><link>https://luma0724.github.io/posts/linked-list-implementation/</link><pubDate>Mon, 09 Jan 2023 13:46:25 +0800</pubDate><guid>https://luma0724.github.io/posts/linked-list-implementation/</guid><description>A linked list can be implemented with pointers and dynamic memory allocation
struct node { int u; struct node* next; node(int x): u(x), next(nullptr) {} }* head=nullptr; int sz, i; // insert node with value x after the jth node void insert(int x, int j) { sz++; node* n=new node(x); if (!</description></item><item><title>Evaluate Reverse Polish Notation</title><link>https://luma0724.github.io/posts/evaluate-reverse-polish-notation/</link><pubDate>Mon, 09 Jan 2023 12:00:05 +0800</pubDate><guid>https://luma0724.github.io/posts/evaluate-reverse-polish-notation/</guid><description>Maintain a stack of result of the arithemetic expression. Push numbers into the stack. If it is an operator, pop two numbers out of the stack and evaluate it with the operator, and push the result back to the stack.</description></item><item><title>Parentheses Balance</title><link>https://luma0724.github.io/posts/parentheses-balance/</link><pubDate>Sun, 08 Jan 2023 16:55:15 +0800</pubDate><guid>https://luma0724.github.io/posts/parentheses-balance/</guid><description>Given a sequence of parentheses, determine if the parentheses are balanced or not. For example, &amp;ldquo;(())(()())&amp;rdquo; is balanced but &amp;ldquo;(()()))(&amp;rdquo; is not balanced.
Solution: Maintain a stack of left parentheses. If a right parentheses mismatches, the sequence is unbalanced.</description></item><item><title>Graph Traversal</title><link>https://luma0724.github.io/posts/graph-traversal/</link><pubDate>Sun, 08 Jan 2023 15:20:25 +0800</pubDate><guid>https://luma0724.github.io/posts/graph-traversal/</guid><description>Depth-first Search> Depth-first Search # Depth-first search explores unvisited path and goes as far as possible, and backtracks to explore a new path. It repeats until there is no path unexplored.</description></item><item><title>Graph Implementation</title><link>https://luma0724.github.io/posts/graph-implementation/</link><pubDate>Sat, 07 Jan 2023 15:49:30 +0800</pubDate><guid>https://luma0724.github.io/posts/graph-implementation/</guid><description>Linked Adjacency List> Linked Adjacency List # A graph can be implemented as a linked adjacency list (more preferred than adjancency matrix or edge list due to memory constraints)
struct edge { int to, next, w; } e[E&amp;lt;&amp;lt;1]; // e[E] if directed graph int head[V], i; void add_edge(int u, int v, int w) { e[++i]={v, head[u], w}; head[u]=i; e[++i]={u, head[v], w}; // undirected graph head[v]=i; } // traversing the graph void dfs(int u, int p) { int i=head[u]; while (i) { // terminate when i=0 if (e[i].</description></item><item><title>CF580C - Kefa and Park</title><link>https://luma0724.github.io/posts/cf-580c/</link><pubDate>Sat, 07 Jan 2023 14:45:12 +0800</pubDate><guid>https://luma0724.github.io/posts/cf-580c/</guid><description>CF580C - Kefa and Park
Depth-first search but maintain $s$ the number of consecutive cats till vertex $u$. If $s&amp;gt;m$, leaves. If $u$ is not vertex 1 and the degree of $u$ is 1, i.</description></item><item><title>CF279B - Books</title><link>https://luma0724.github.io/posts/cf-279b/</link><pubDate>Fri, 06 Jan 2023 12:37:01 +0800</pubDate><guid>https://luma0724.github.io/posts/cf-279b/</guid><description>CF279B - Books
Use 2-pointers $i, j$ to iterate throught $i=1..n$ to find $j$ such that $\sum_{k=j}^i a[k] &amp;lt;= t$ is maximized in order to find the $\max(i-j+1)$.
#include &amp;lt;bits/stdc++.</description></item><item><title>CF489B - BerSU Ball</title><link>https://luma0724.github.io/posts/cf-489b/</link><pubDate>Thu, 05 Jan 2023 11:24:58 +0800</pubDate><guid>https://luma0724.github.io/posts/cf-489b/</guid><description>CF489B - BerSU Ball
Sort arrays $a, b$. Match $a[i], b[j]$ greedily with two pointers $i, j$. Assume $a[x], b[y]$ the first pair inconsistent with the optimal pair. Note that if $a[i^\prime], b[j^\prime]$ match, $b[j^\prime]$ is always the minimum $b[j]$ upon $a[i]$ not paired in array $b$.</description></item><item><title>CF381A - Sereja and Dima</title><link>https://luma0724.github.io/posts/cf-381a/</link><pubDate>Thu, 05 Jan 2023 10:50:14 +0800</pubDate><guid>https://luma0724.github.io/posts/cf-381a/</guid><description>CF381A - Sereja and Dima
Let $x[n]$ be the cards and $l, r$ the left and right pointers. Sereja and Dima takes $\max(x[l], x[r])$ greedily each round then move the pointers.</description></item><item><title>CF706B - Interesting Drink</title><link>https://luma0724.github.io/posts/cf-706b/</link><pubDate>Wed, 04 Jan 2023 13:45:08 +0800</pubDate><guid>https://luma0724.github.io/posts/cf-706b/</guid><description>CF706B - Interesting Drink
Let $c[max(x)]$ array such that $a[x]$ is the number of $x$. Let $s[max(x)]$ be the prefix sum of $c[max(x)]$ given by
$$s[i] = s[i-1] + c[i]$$ with $s[1] = c[1]$.</description></item><item><title>CF455A - Boredom</title><link>https://luma0724.github.io/posts/cf-455a/</link><pubDate>Wed, 04 Jan 2023 11:39:23 +0800</pubDate><guid>https://luma0724.github.io/posts/cf-455a/</guid><description>CF455A - Boredom
The problem asks to maximize the score. Given an array $a[n]$, the score given by deleting $a[k]$ is $a[k]m[a[k]]$ where $m[a[k]]$ is the number of $a[k]$ in the array.</description></item><item><title>CF189A - Cut Ribbon</title><link>https://luma0724.github.io/posts/cf-189a/</link><pubDate>Wed, 04 Jan 2023 09:25:51 +0800</pubDate><guid>https://luma0724.github.io/posts/cf-189a/</guid><description>Complete Knapsack Problem: Given $a[4]$ weight of items with each value 1 and knapsack capacity $n$, define
$$dp[n^\prime] = \sum_{i=1}^{3} k[i]$$
the maximum value with knapsack with capacity $n^\prime$ such that $k[i] &amp;gt;= 0$ is the number of times $a[i]$ is taken and</description></item><item><title>CF489C - Given Length and Sum of Digits...</title><link>https://luma0724.github.io/posts/cf-489c/</link><pubDate>Tue, 03 Jan 2023 14:47:41 +0800</pubDate><guid>https://luma0724.github.io/posts/cf-489c/</guid><description>CF489C - Given Length and Sum of Digits&amp;hellip;
Let $x$ and $y$ be the maximum and mininum number with length $m$ and sum of digits $s$. Note that maximum sum of digits of length $m$ is $9m$ and if $s=0$, then there are no solutions with length $m&amp;gt;1$.</description></item></channel></rss>